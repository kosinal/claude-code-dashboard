import { execSync } from "node:child_process";
import * as fs from "node:fs";
import * as os from "node:os";
import * as path from "node:path";
import { installHooksWithCommand, removeHooks } from "./hooks.ts";

const DASHBOARD_DIR = path.join(os.homedir(), ".claude", "dashboard");
const BIN_DIR = path.join(os.homedir(), ".claude", "bin");
const CONFIG_PATH = path.join(DASHBOARD_DIR, "config.json");
const SERVER_DIR = path.join(DASHBOARD_DIR, "server");
const HOOK_SCRIPT_PATH = path.join(BIN_DIR, "claude-dashboard-hook.mjs");
export const LOCK_PATH = path.join(DASHBOARD_DIR, "dashboard.lock");

const PROTOCOL_SCHEME = "claude-dashboard";

function getThisBundle(): string {
  // In bundled form, __filename points to dist/bin.js
  return process.argv[1] ?? __filename;
}

function writeHookScript(_port: number, _serverEntry: string): void {
  const script = `#!/usr/bin/env node
// Auto-generated by claude-code-dashboard install
import { readFileSync, existsSync, unlinkSync } from 'node:fs';
import { spawn, exec } from 'node:child_process';
import { request } from 'node:http';
import { openSync } from 'node:fs';

const CONFIG_PATH = ${JSON.stringify(CONFIG_PATH)};
const LOCK_PATH = ${JSON.stringify(LOCK_PATH)};

let config;
try {
  config = JSON.parse(readFileSync(CONFIG_PATH, 'utf-8'));
} catch {
  process.exit(0); // Config missing — probably uninstalled
}

const { port, serverEntry } = config;
const stdin = readFileSync(0, 'utf-8');

function postHook(data) {
  return new Promise((resolve, reject) => {
    const req = request({
      hostname: '127.0.0.1',
      port,
      path: '/api/hook',
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      timeout: 5000,
    }, (res) => {
      res.resume();
      resolve(res.statusCode);
    });
    req.on('error', reject);
    req.on('timeout', () => { req.destroy(); reject(new Error('timeout')); });
    req.write(data);
    req.end();
  });
}

function httpPing() {
  return new Promise((resolve, reject) => {
    const req = request({
      hostname: '127.0.0.1',
      port,
      path: '/api/sessions',
      method: 'GET',
      timeout: 2000,
    }, (res) => {
      res.resume();
      resolve(res.statusCode);
    });
    req.on('error', reject);
    req.on('timeout', () => { req.destroy(); reject(new Error('timeout')); });
    req.end();
  });
}

async function isServerRunning() {
  try {
    if (!existsSync(LOCK_PATH)) return false;
    const pid = parseInt(readFileSync(LOCK_PATH, 'utf-8').trim().split(':')[0], 10);
    if (isNaN(pid)) return false;
    try {
      process.kill(pid, 0); // Check if process exists
    } catch (e) {
      // On Windows, EPERM can be thrown for processes we can't signal but that exist.
      // Only treat ESRCH (no such process) as definitely dead.
      if (e && e.code === 'ESRCH') {
        try { unlinkSync(LOCK_PATH); } catch { /* ignore */ }
        return false;
      }
      // EPERM — process might exist, fall through to HTTP check
    }
    // PID check passed or was ambiguous — verify with HTTP ping
    try {
      await httpPing();
      return true;
    } catch {
      // HTTP ping failed — server is not actually running, clean stale lock
      try { unlinkSync(LOCK_PATH); } catch { /* ignore */ }
      return false;
    }
  } catch {
    return false;
  }
}

function openBrowser(url) {
  const platform = process.platform;
  const cmd = platform === 'win32'
    ? \`start "" "\${url}"\`
    : platform === 'darwin'
      ? \`open "\${url}"\`
      : \`xdg-open "\${url}"\`;
  exec(cmd, () => {});
}

function startServer() {
  const logPath = ${JSON.stringify(path.join(DASHBOARD_DIR, "server.log"))};
  const logFd = openSync(logPath, 'a');
  const child = spawn(process.execPath, [serverEntry, '--no-hooks', '--no-open', '--port', String(port)], {
    detached: true,
    stdio: ['ignore', logFd, logFd],
    env: { ...process.env },
  });
  child.unref();
}

async function waitForServer(maxWaitMs = 10000) {
  const start = Date.now();
  let delay = 100;
  while (Date.now() - start < maxWaitMs) {
    try {
      await httpPing();
      return true;
    } catch {
      await new Promise(r => setTimeout(r, delay));
      delay = Math.min(delay * 1.5, 1000);
    }
  }
  return false;
}

async function main() {
  try {
    await postHook(stdin);
  } catch {
    // Server not running — try to start it
    const running = await isServerRunning();
    if (!running) {
      startServer();
    }
    const ready = await waitForServer();
    if (ready) {
      if (!running) {
        // We just auto-started the server — open the browser
        openBrowser(\`http://localhost:\${port}\`);
      }
      try { await postHook(stdin); } catch { /* give up */ }
    }
  }
}

main().catch(() => {});
`;

  fs.mkdirSync(path.dirname(HOOK_SCRIPT_PATH), { recursive: true });
  fs.writeFileSync(HOOK_SCRIPT_PATH, script);
}

// ---------------------------------------------------------------------------
// Shortcut creation / removal
// ---------------------------------------------------------------------------

function getShortcutPath(): string | null {
  const platform = process.platform;
  if (platform === "win32") {
    const appData = process.env.APPDATA;
    if (!appData) return null;
    return path.join(
      appData,
      "Microsoft",
      "Windows",
      "Start Menu",
      "Programs",
      "Claude Dashboard.url",
    );
  }
  if (platform === "darwin") {
    return path.join(os.homedir(), "Applications", "Claude Dashboard.webloc");
  }
  // Linux / other
  return path.join(os.homedir(), ".local", "share", "applications", "claude-dashboard.desktop");
}

function createShortcuts(port: number): void {
  const shortcutPath = getShortcutPath();
  if (!shortcutPath) return;

  fs.mkdirSync(path.dirname(shortcutPath), { recursive: true });

  const platform = process.platform;
  const url = `http://localhost:${port}`;

  if (platform === "win32") {
    const content = `[InternetShortcut]\nURL=${url}\nIconIndex=0\n`;
    fs.writeFileSync(shortcutPath, content);
  } else if (platform === "darwin") {
    const content = [
      '<?xml version="1.0" encoding="UTF-8"?>',
      '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">',
      '<plist version="1.0">',
      "<dict>",
      "\t<key>URL</key>",
      `\t<string>${url}</string>`,
      "</dict>",
      "</plist>",
      "",
    ].join("\n");
    fs.writeFileSync(shortcutPath, content);
  } else {
    const content = [
      "[Desktop Entry]",
      "Version=1.1",
      "Type=Link",
      "Name=Claude Dashboard",
      `URL=${url}`,
      "Icon=text-html",
      "",
    ].join("\n");
    fs.writeFileSync(shortcutPath, content);
  }

  console.log(`  Shortcut:      ${shortcutPath}`);
}

function removeShortcuts(): void {
  const shortcutPath = getShortcutPath();
  if (!shortcutPath) return;
  try {
    fs.unlinkSync(shortcutPath);
  } catch {
    // Ignore — may not exist
  }
}

// ---------------------------------------------------------------------------
// Protocol handler registration / removal
// ---------------------------------------------------------------------------

function getProtocolDesktopPath(): string {
  return path.join(
    os.homedir(),
    ".local",
    "share",
    "applications",
    "claude-dashboard-handler.desktop",
  );
}

function registerProtocol(port: number): void {
  const platform = process.platform;
  const url = `http://localhost:${port}`;

  try {
    if (platform === "win32") {
      const regBase = `HKCU\\Software\\Classes\\${PROTOCOL_SCHEME}`;
      execSync(`reg add "${regBase}" /ve /d "URL:Claude Dashboard" /f`, { stdio: "ignore" });
      execSync(`reg add "${regBase}" /v "URL Protocol" /d "" /f`, { stdio: "ignore" });
      execSync(`reg add "${regBase}\\shell\\open\\command" /ve /d "cmd /c start ${url}" /f`, {
        stdio: "ignore",
      });
    } else if (platform === "darwin") {
      // Create a minimal .app bundle that redirects to the dashboard URL
      const appDir = path.join(
        os.homedir(),
        "Applications",
        "Claude Dashboard Protocol.app",
        "Contents",
      );
      const macOSDir = path.join(appDir, "MacOS");
      fs.mkdirSync(macOSDir, { recursive: true });

      const infoPlist = [
        '<?xml version="1.0" encoding="UTF-8"?>',
        '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">',
        '<plist version="1.0">',
        "<dict>",
        "\t<key>CFBundleIdentifier</key>",
        "\t<string>com.claude-dashboard.protocol</string>",
        "\t<key>CFBundleName</key>",
        "\t<string>Claude Dashboard Protocol</string>",
        "\t<key>CFBundleExecutable</key>",
        "\t<string>open-dashboard</string>",
        "\t<key>CFBundleURLTypes</key>",
        "\t<array>",
        "\t\t<dict>",
        "\t\t\t<key>CFBundleURLName</key>",
        "\t\t\t<string>Claude Dashboard</string>",
        "\t\t\t<key>CFBundleURLSchemes</key>",
        "\t\t\t<array>",
        `\t\t\t\t<string>${PROTOCOL_SCHEME}</string>`,
        "\t\t\t</array>",
        "\t\t</dict>",
        "\t</array>",
        "</dict>",
        "</plist>",
        "",
      ].join("\n");
      fs.writeFileSync(path.join(appDir, "Info.plist"), infoPlist);

      const launchScript = `#!/bin/sh\nopen "${url}"\n`;
      const scriptPath = path.join(macOSDir, "open-dashboard");
      fs.writeFileSync(scriptPath, launchScript, { mode: 0o755 });

      // Register with Launch Services
      try {
        execSync(
          `/System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support/lsregister -R "${path.dirname(appDir)}"`,
          { stdio: "ignore" },
        );
      } catch {
        // lsregister may not be available; the .app should still work on next login
      }
    } else {
      // Linux — XDG desktop entry for protocol handler
      const desktopPath = getProtocolDesktopPath();
      fs.mkdirSync(path.dirname(desktopPath), { recursive: true });

      const content = [
        "[Desktop Entry]",
        "Version=1.1",
        "Type=Application",
        "Name=Claude Dashboard Protocol Handler",
        `Exec=xdg-open ${url}`,
        `MimeType=x-scheme-handler/${PROTOCOL_SCHEME};`,
        "NoDisplay=true",
        "",
      ].join("\n");
      fs.writeFileSync(desktopPath, content);

      try {
        execSync(
          `xdg-mime default claude-dashboard-handler.desktop x-scheme-handler/${PROTOCOL_SCHEME}`,
          { stdio: "ignore" },
        );
      } catch {
        // xdg-mime may not be available
      }
    }
  } catch {
    // Protocol registration is best-effort; don't fail install
  }

  console.log(`  Protocol:      ${PROTOCOL_SCHEME}:// registered`);
}

function unregisterProtocol(): void {
  const platform = process.platform;

  try {
    if (platform === "win32") {
      execSync(`reg delete "HKCU\\Software\\Classes\\${PROTOCOL_SCHEME}" /f`, { stdio: "ignore" });
    } else if (platform === "darwin") {
      const appDir = path.join(os.homedir(), "Applications", "Claude Dashboard Protocol.app");
      fs.rmSync(appDir, { recursive: true, force: true });
    } else {
      const desktopPath = getProtocolDesktopPath();
      try {
        fs.unlinkSync(desktopPath);
      } catch {
        // Ignore
      }
      try {
        execSync("update-desktop-database ~/.local/share/applications/", {
          stdio: "ignore",
        });
      } catch {
        // Ignore
      }
    }
  } catch {
    // Cleanup is best-effort
  }
}

// ---------------------------------------------------------------------------
// Install / Uninstall
// ---------------------------------------------------------------------------

export function install(port: number): void {
  // 1. Create directories
  fs.mkdirSync(SERVER_DIR, { recursive: true });
  fs.mkdirSync(BIN_DIR, { recursive: true });

  // 2. Copy bundle to persistent location
  const bundleSrc = getThisBundle();
  const bundleDest = path.join(SERVER_DIR, "bin.js");
  fs.copyFileSync(bundleSrc, bundleDest);

  // 3. Write config
  fs.writeFileSync(CONFIG_PATH, `${JSON.stringify({ port, serverEntry: bundleDest }, null, 2)}\n`);

  // 4. Write hook helper script
  writeHookScript(port, bundleDest);

  // 5. Install hooks pointing to the helper script
  const command = `node ${JSON.stringify(HOOK_SCRIPT_PATH)}`;
  installHooksWithCommand(command);

  console.log("Dashboard installed successfully!");
  console.log(`  Server bundle: ${bundleDest}`);
  console.log(`  Hook script:   ${HOOK_SCRIPT_PATH}`);
  console.log(`  Config:        ${CONFIG_PATH}`);
  console.log(`  Port:          ${port}`);

  // 6. Create desktop/start-menu shortcut
  createShortcuts(port);

  // 7. Register protocol handler
  registerProtocol(port);

  console.log("");
  console.log("The dashboard will auto-launch when a Claude Code session starts.");
  console.log(
    `You can also open it via the shortcut or by typing "${PROTOCOL_SCHEME}://" in your browser.`,
  );
  console.log("To uninstall: npx @kosinal/claude-code-dashboard uninstall");
}

export function uninstall(): void {
  // 1. Remove all hooks from settings.json (both modes)
  removeHooks();

  // 2. Remove shortcuts and protocol handler
  removeShortcuts();
  unregisterProtocol();

  // 3. Remove dashboard directory
  try {
    fs.rmSync(DASHBOARD_DIR, { recursive: true, force: true });
  } catch {
    // Ignore — may not exist
  }

  // 4. Remove hook script
  try {
    fs.unlinkSync(HOOK_SCRIPT_PATH);
  } catch {
    // Ignore — may not exist
  }

  console.log("Dashboard uninstalled successfully.");
  console.log("  Shortcut removed, protocol handler unregistered.");
}

export function writeLockFile(port: number): void {
  fs.mkdirSync(DASHBOARD_DIR, { recursive: true });
  fs.writeFileSync(LOCK_PATH, `${process.pid}:${port}`);
}

export function readLockFile(): { pid: number; port: number } | null {
  try {
    const content = fs.readFileSync(LOCK_PATH, "utf-8").trim();
    const parts = content.split(":");
    const pid = parseInt(parts[0], 10);
    const port = parts.length > 1 ? parseInt(parts[1], 10) : NaN;
    if (Number.isNaN(pid) || Number.isNaN(port)) return null;
    // Check if process is alive
    try {
      process.kill(pid, 0);
    } catch (err: unknown) {
      const code = (err as NodeJS.ErrnoException).code;
      if (code === "ESRCH") {
        // Process definitely dead — clean up stale lock
        try {
          fs.unlinkSync(LOCK_PATH);
        } catch {
          /* ignore */
        }
        return null;
      }
      // EPERM on Windows — process may exist but we can't signal it.
      // Return the lock data; callers should verify with HTTP if needed.
    }
    return { pid, port };
  } catch {
    // File missing or parse error — clean up stale lock
    try {
      fs.unlinkSync(LOCK_PATH);
    } catch {
      /* ignore */
    }
    return null;
  }
}

export function removeLockFile(): void {
  try {
    fs.unlinkSync(LOCK_PATH);
  } catch {
    // Ignore
  }
}
