import * as fs from "node:fs";
import * as path from "node:path";
import * as os from "node:os";
import { installHooksWithCommand, removeHooks } from "./hooks.ts";

const DASHBOARD_DIR = path.join(os.homedir(), ".claude", "dashboard");
const BIN_DIR = path.join(os.homedir(), ".claude", "bin");
const CONFIG_PATH = path.join(DASHBOARD_DIR, "config.json");
const SERVER_DIR = path.join(DASHBOARD_DIR, "server");
const HOOK_SCRIPT_PATH = path.join(BIN_DIR, "claude-dashboard-hook.mjs");
export const LOCK_PATH = path.join(DASHBOARD_DIR, "dashboard.lock");

function getThisBundle(): string {
  // In bundled form, __filename points to dist/bin.js
  return process.argv[1] ?? __filename;
}

function writeHookScript(port: number, serverEntry: string): void {
  const script = `#!/usr/bin/env node
// Auto-generated by claude-code-dashboard install
import { readFileSync, existsSync, writeFileSync } from 'node:fs';
import { spawn } from 'node:child_process';
import { request } from 'node:http';
import { openSync } from 'node:fs';

const CONFIG_PATH = ${JSON.stringify(CONFIG_PATH)};
const LOCK_PATH = ${JSON.stringify(LOCK_PATH)};

let config;
try {
  config = JSON.parse(readFileSync(CONFIG_PATH, 'utf-8'));
} catch {
  process.exit(0); // Config missing — probably uninstalled
}

const { port, serverEntry } = config;
const stdin = readFileSync(0, 'utf-8');

function postHook(data) {
  return new Promise((resolve, reject) => {
    const req = request({
      hostname: '127.0.0.1',
      port,
      path: '/api/hook',
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      timeout: 5000,
    }, (res) => {
      res.resume();
      resolve(res.statusCode);
    });
    req.on('error', reject);
    req.on('timeout', () => { req.destroy(); reject(new Error('timeout')); });
    req.write(data);
    req.end();
  });
}

function isServerRunning() {
  try {
    if (!existsSync(LOCK_PATH)) return false;
    const pid = parseInt(readFileSync(LOCK_PATH, 'utf-8').trim().split(':')[0], 10);
    if (isNaN(pid)) return false;
    process.kill(pid, 0); // Check if process exists
    return true;
  } catch {
    return false;
  }
}

function startServer() {
  const logPath = ${JSON.stringify(path.join(DASHBOARD_DIR, "server.log"))};
  const logFd = openSync(logPath, 'a');
  const child = spawn(process.execPath, [serverEntry, '--no-hooks', '--no-open', '--port', String(port)], {
    detached: true,
    stdio: ['ignore', logFd, logFd],
    env: { ...process.env },
  });
  child.unref();
}

async function waitForServer(maxWaitMs = 10000) {
  const start = Date.now();
  let delay = 100;
  while (Date.now() - start < maxWaitMs) {
    try {
      await postHook('{"session_id":"ping","hook_event_name":"Ping"}');
      return true;
    } catch {
      await new Promise(r => setTimeout(r, delay));
      delay = Math.min(delay * 1.5, 1000);
    }
  }
  return false;
}

async function main() {
  try {
    await postHook(stdin);
  } catch {
    // Server not running — try to start it
    if (!isServerRunning()) {
      startServer();
    }
    const ready = await waitForServer();
    if (ready) {
      try { await postHook(stdin); } catch { /* give up */ }
    }
  }
}

main().catch(() => {});
`;

  fs.mkdirSync(path.dirname(HOOK_SCRIPT_PATH), { recursive: true });
  fs.writeFileSync(HOOK_SCRIPT_PATH, script);
}

export function install(port: number): void {
  // 1. Create directories
  fs.mkdirSync(SERVER_DIR, { recursive: true });
  fs.mkdirSync(BIN_DIR, { recursive: true });

  // 2. Copy bundle to persistent location
  const bundleSrc = getThisBundle();
  const bundleDest = path.join(SERVER_DIR, "bin.js");
  fs.copyFileSync(bundleSrc, bundleDest);

  // 3. Write config
  fs.writeFileSync(
    CONFIG_PATH,
    JSON.stringify({ port, serverEntry: bundleDest }, null, 2) + "\n"
  );

  // 4. Write hook helper script
  writeHookScript(port, bundleDest);

  // 5. Install hooks pointing to the helper script
  const command = `node ${JSON.stringify(HOOK_SCRIPT_PATH)}`;
  installHooksWithCommand(command);

  console.log("Dashboard installed successfully!");
  console.log(`  Server bundle: ${bundleDest}`);
  console.log(`  Hook script:   ${HOOK_SCRIPT_PATH}`);
  console.log(`  Config:        ${CONFIG_PATH}`);
  console.log(`  Port:          ${port}`);
  console.log("");
  console.log(
    "The dashboard will auto-launch when a Claude Code session starts."
  );
  console.log(
    "To uninstall: npx @kosinal/claude-code-dashboard uninstall"
  );
}

export function uninstall(): void {
  // 1. Remove hooks from settings.json
  removeHooks();

  // 2. Remove dashboard directory
  try {
    fs.rmSync(DASHBOARD_DIR, { recursive: true, force: true });
  } catch {
    // Ignore — may not exist
  }

  // 3. Remove hook script
  try {
    fs.unlinkSync(HOOK_SCRIPT_PATH);
  } catch {
    // Ignore — may not exist
  }

  console.log("Dashboard uninstalled successfully.");
}

export function writeLockFile(port: number): void {
  fs.mkdirSync(DASHBOARD_DIR, { recursive: true });
  fs.writeFileSync(LOCK_PATH, `${process.pid}:${port}`);
}

export function readLockFile(): { pid: number; port: number } | null {
  try {
    const content = fs.readFileSync(LOCK_PATH, "utf-8").trim();
    const parts = content.split(":");
    const pid = parseInt(parts[0], 10);
    const port = parts.length > 1 ? parseInt(parts[1], 10) : NaN;
    if (isNaN(pid) || isNaN(port)) return null;
    // Check if process is alive
    process.kill(pid, 0);
    return { pid, port };
  } catch {
    // Process dead or file missing — clean up stale lock
    try { fs.unlinkSync(LOCK_PATH); } catch { /* ignore */ }
    return null;
  }
}

export function removeLockFile(): void {
  try {
    fs.unlinkSync(LOCK_PATH);
  } catch {
    // Ignore
  }
}
